import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class Utility {

    /**
     * Calculate the Euclidean distance between two VRP nodes
     * @param node1 the first VRP node
     * @param node2 the second VRP node
     * @return the Euclidean distance between node1 and node2
     */
    public static double calculateEuclideanDistance(VRPNode node1, VRPNode node2) {
        // TODO: Implement the function to calculate the Euclidean distance.
        double distance = 0.0;
        double xDist = node1.getX() - node2.getX();
        double yDist = node1.getY() - node2.getY();
        distance = Math.sqrt((xDist * xDist) + (yDist * yDist));
        return distance;
    }

    /**
     * Calculate the total cost of a VRP solution under a VRP instance.
     * The total cost is the sum of all the Euclidean distance between adjacent nodes in the routes.
     * @param solution the VRP solution.
     * @param instance the VRP instance.
     * @return the total cost of the solution.
     */
    public static double calculateTotalCost(VRPSolution solution, VRPInstance instance) {
        // TODO: Implement the function to calculate the total cost of the solution.
        double totalCost = 0.0;
        Map<Integer, VRPNode> nodes = instance.getNodes();
        for(List<Integer> route : solution.getRoutes()){
            for(int i =0; i < route.size()-1; i++){
                VRPNode currentNode = nodes.get(route.get(i)+1);
                VRPNode nextNode = nodes.get(route.get(i+1)+1);
                totalCost += calculateEuclideanDistance(currentNode, nextNode);
            }
        }
        return totalCost;
    }

    /**
     * Calculate a distance matrix for an instance
     * @param instance
     * @return
     */
    public static double[][] calculateDistanceMatrix(VRPInstance instance) {
        Map<Integer, VRPNode> nodes = instance.getNodes();
        double[][] distMatrix = new double[nodes.size()][nodes.size()];
        for(Map.Entry<Integer, VRPNode> entry1 : instance.getNodes().entrySet()){
            for(Map.Entry<Integer, VRPNode> entry2 : instance.getNodes().entrySet()){
                distMatrix[entry1.getKey()-1][entry2.getKey()-1] = calculateEuclideanDistance(entry1.getValue(), entry2.getValue());
            }
        }
        return distMatrix;
    }

    /**
     * Generate a VRP solution for a VRP instance using the nearest neighbour heuristic.
     * @param instance the VRP instance.
     * @return the VRP solution generated by the nearest neighbour heuristic.
     */
    public static VRPSolution nearestNeighbourHeuristic(VRPInstance instance) {
        // TODO: Implement the nearest neighbour heuristic.
        Map<Integer, VRPNode> nodes = instance.getNodes();
        List<List<Integer>> routes = new ArrayList<List<Integer>>();
        List<Integer> currentRoute;
        List<Integer> visited = new ArrayList<Integer>();
        VRPNode nearestNode = null;
        VRPNode currentNode = instance.getDepot();
        double nearestNodeDist = Integer.MAX_VALUE;
        double nodeDistance = 0.0;
        currentRoute = new ArrayList<Integer>();
        double routeDemand;
        currentRoute.add(currentNode.getID()-1);
        boolean added = false;
        double[][] distanceMatrix = calculateDistanceMatrix(instance);
        
        while(visited.size() < nodes.size() - 1){ // create routes until all nodes have been visited
            routeDemand = 0.0;
            currentNode = instance.getDepot();
            currentRoute.clear();
            currentRoute.add(currentNode.getID()-1);
            added = true;
            while (routeDemand < instance.getCapacity() && added) { // add to route while capacity is not max, and we added a node last iteration
                added = false;
                nearestNode = null;
                nearestNodeDist = Double.MAX_VALUE;
                for(VRPNode node : nodes.values()){
                    if(!visited.contains(node.getID()) &&
                    node.getID() != instance.getDepot().getID()){ // ignore node if already visited, or is the depot
                        nodeDistance = distanceMatrix[currentNode.getID()-1][node.getID()-1]; // find relevant dist in distMatrix
                        if(nodeDistance < nearestNodeDist && routeDemand + node.getDemand() <= instance.getCapacity()){
                            nearestNodeDist = nodeDistance;
                            nearestNode = node;
                            added = true;
                        }
                    }
                }
                if(added && nearestNode != null){
                    currentRoute.add(nearestNode.getID()-1); // Add the nearest node to the route
                    visited.add(nearestNode.getID()); // nearest node has been visited
                    currentNode = nearestNode; // next iteration from nearest node
                    routeDemand += nearestNode.getDemand();
                }
            }
            currentRoute.add(instance.getDepot().getID()-1); // append depot at the end
            routes.add(List.copyOf(currentRoute));
        }
        VRPSolution solution = new VRPSolution(routes);
        System.out.println(calculateTotalCost(solution, instance));
        return solution;
    }
    
    /**
     * Generate a VRP solution for a VRP instance using the savings heuristic.
     * @param instance the VRP instance.
     * @return the VRP solution generated by the savings heuristic.
     */
    public static VRPSolution savingsHeuristic(VRPInstance instance) {
        // TODO: Implement the savings heuristic.
        Map<Integer, VRPNode> nodes = instance.getNodes();
        VRPNode depot = instance.getDepot();
        double[][] distanceMatrix = calculateDistanceMatrix(instance);
        List<SavingsEntry> savings = new ArrayList<SavingsEntry>();
        
        // calculates the savings between nodes.
        for(int i = 1; i < nodes.size(); i++){
            for(int j = 1; j < nodes.size(); j++){
                double saving = distanceMatrix[depot.getID()-1][i] + distanceMatrix[j][depot.getID()-1] - distanceMatrix[i][j];
                savings.add(new SavingsEntry(nodes.get(i+1), nodes.get(j+1), saving));
            }
        }
        Collections.sort(savings);
        
        Map<Integer, List<Integer>> routes = new HashMap<>();
        for (int i = 1; i < nodes.size(); i++) {
            // initialise cycles (depot -> node -> depot)
            List<Integer> route = new ArrayList<>();
            route.add(depot.getID()-1);
            route.add(i);
            route.add(depot.getID()-1);
            routes.put(i, route);
        }

        // calculates the route demands
        Map<List<Integer>, Double> routeDemands = new HashMap<>();
        for(Map.Entry<Integer, List<Integer>> entry : routes.entrySet()){
            routeDemands.put(entry.getValue(), nodes.get(entry.getKey()+1).getDemand());
        }

        boolean mergeComplete = true;
        // check each possible merge
        do{
            mergeComplete = false;
            for(SavingsEntry merge : savings){
                VRPNode iNode = merge.getI();
                VRPNode jNode = merge.getJ();
                List<Integer> routeI = routes.get(iNode.getID()-1);
                List<Integer> routeJ = routes.get(jNode.getID()-1);
                double demandI = routeDemands.get(routeI);
                double demandJ = routeDemands.get(routeJ);
                //checks if it's still a valid merge
                if(routeI != routeJ && demandI + demandJ <= instance.getCapacity()){
                    if(routeI.get(routeI.size()-2) == iNode.getID()-1 && routeJ.get(1) == jNode.getID()-1){
                        routeI.remove(routeI.size()-1);
                        routeI.addAll(routeJ.subList(1, routeJ.size()));
                        for(int i : routeI){
                            routes.put(i, routeI);
                        }
                        routes.remove(jNode.getID()-1, routeJ);
                        routeDemands.put(routeI, demandI + demandJ);
                        List<SavingsEntry> toRemove = new ArrayList<>();
                        for(SavingsEntry s : savings){
                             // remove all merges that would break up the merge just done
                            if(s.getI() == iNode || s.getJ() == jNode){
                                toRemove.add(s);
                            }
                        }
                        savings.removeAll(toRemove);
                        // a merge has been made, so break out of the loop
                        mergeComplete = true;
                        break;
                    }
                }
            }
        } while(mergeComplete); // go until there is no valid merge to do
        Set<List<Integer>> uniqueRoutesSet = new HashSet<>(routes.values()); // put into a set to get rid of duplicate routes
        List<List<Integer>> finalRoutes = new ArrayList<>(uniqueRoutesSet);
        VRPSolution solution = new VRPSolution(finalRoutes);
        System.out.println(calculateTotalCost(solution, instance));
        return solution;
    }

}
